import { Notice, TFile, Vault, normalizePath, requestUrl, App } from "obsidian";
import type { Monster } from "index";
import OpenAI from "openai";

/**
 * OpenAI Image Generator Service
 * Generates creature images using DALL-E API
 */

export interface ImageGenerationOptions {
    apiKey: string;
    style: string;
    saveFolder: string;
}

export class OpenAIImageGenerator {
    /**
     * Generate a DALL-E prompt from monster data
     */
    static generatePromptFromMonster(monster: Partial<Monster>, style: string): string {
        const parts: string[] = [];

        // Base description
        if (monster.name) {
            parts.push(`A creature named ${monster.name}`);
        }

        // Size and type
        const sizeType: string[] = [];
        if (monster.size) sizeType.push(monster.size.toLowerCase());
        if (monster.type) sizeType.push(monster.type.toLowerCase());
        if (sizeType.length > 0) {
            parts.push(sizeType.join(" "));
        }

        // Alignment for character flavor
        if (monster.alignment && monster.alignment !== "unaligned") {
            const alignmentDescriptors: Record<string, string> = {
                "lawful good": "noble and virtuous",
                "neutral good": "kind and benevolent",
                "chaotic good": "free-spirited and heroic",
                "lawful neutral": "orderly and disciplined",
                "neutral": "balanced",
                "chaotic neutral": "unpredictable and wild",
                "lawful evil": "tyrannical and cruel",
                "neutral evil": "malicious and selfish",
                "chaotic evil": "destructive and malevolent"
            };
            const descriptor = alignmentDescriptors[monster.alignment.toLowerCase()];
            if (descriptor) {
                parts.push(`with a ${descriptor} demeanor`);
            }
        }

        // Prioritize explicit appearance property
        if (monster.appearance) {
            parts.push(monster.appearance);
        } else {
            // Fallback: Add description if available
            if (monster.description) {
                parts.push(monster.description);
            }

            // Fallback: Extract appearance from traits
            if (monster.traits && Array.isArray(monster.traits)) {
                const appearanceTraits = monster.traits
                    .filter((t) =>
                        t.name?.toLowerCase().includes("appearance") ||
                        t.desc?.toLowerCase().includes("looks like") ||
                        t.desc?.toLowerCase().includes("appears as")
                    )
                    .map((t) => t.desc)
                    .slice(0, 2); // Limit to avoid token overflow

                if (appearanceTraits.length > 0) {
                    parts.push(appearanceTraits.join(". "));
                }
            }
        }

        // Build final prompt
        let prompt = parts.join(", ");

        // Add style instruction and explicit no-text directive
        prompt += `. ${style} style, high quality, detailed, fantasy RPG creature portrait, dramatic lighting. NO text, letters, words, or labels should appear in the image`;

        // Ensure prompt isn't too long (DALL-E has limits)
        if (prompt.length > 1000) {
            prompt = prompt.substring(0, 997) + "...";
        }

        return prompt;
    }

    /**
     * Generate an image using OpenAI DALL-E
     */
    static async generateImage(
        prompt: string,
        apiKey: string
    ): Promise<string> {
        if (!apiKey || apiKey.trim() === "") {
            throw new Error("OpenAI API key is not configured. Please add it in Fantasy Statblocks settings.");
        }

        try {
            const openai = new OpenAI({
                apiKey: apiKey,
                dangerouslyAllowBrowser: true // Required for client-side usage in Obsidian
            });

            const response = await openai.images.generate({
                model: "dall-e-3",
                prompt: prompt,
                n: 1,
                size: "1024x1024",
                quality: "standard",
            });

            if (!response.data || response.data.length === 0) {
                throw new Error("No image was generated by OpenAI");
            }

            const imageUrl = response.data[0].url;
            if (!imageUrl) {
                throw new Error("No image URL returned from OpenAI");
            }

            return imageUrl;
        } catch (error: any) {
            if (error.status === 401) {
                throw new Error("Invalid OpenAI API key. Please check your settings.");
            } else if (error.status === 429) {
                throw new Error("OpenAI API rate limit exceeded. Please try again later.");
            } else if (error.status === 400) {
                throw new Error("Invalid request to OpenAI. The prompt may contain prohibited content.");
            } else {
                throw new Error(`OpenAI API error: ${error.message || "Unknown error"}`);
            }
        }
    }

    /**
     * Download image from URL and save to vault
     */
    static async saveImageToVault(
        imageUrl: string,
        vault: Vault,
        folderPath: string,
        monsterName: string
    ): Promise<string> {
        try {
            // Ensure folder exists
            const normalizedFolder = normalizePath(folderPath);
            const folderExists = await vault.adapter.exists(normalizedFolder);
            if (!folderExists) {
                await vault.adapter.mkdir(normalizedFolder);
            }

            // Download image using Obsidian's requestUrl to bypass CORS
            const response = await requestUrl({
                url: imageUrl,
                method: "GET"
            });

            if (response.status !== 200) {
                throw new Error(`Failed to download image: ${response.status}`);
            }

            // Get the array buffer from the response
            const arrayBuffer = response.arrayBuffer;

            // Generate filename
            const timestamp = Date.now();
            const safeName = monsterName.replace(/[^a-z0-9]/gi, "_").toLowerCase();
            const filename = `${safeName}_${timestamp}.png`;
            const filePath = normalizePath(`${normalizedFolder}/${filename}`);

            // Save to vault
            await vault.adapter.writeBinary(filePath, arrayBuffer);

            return filePath;
        } catch (error: any) {
            throw new Error(`Failed to save image to vault: ${error.message}`);
        }
    }

    /**
     * Update the image property in a creature's frontmatter
     */
    static async updateCreatureFrontmatter(
        app: App,
        filePath: string,
        imagePath: string
    ): Promise<boolean> {
        try {
            // Get the file
            const file = app.vault.getAbstractFileByPath(filePath);

            if (!file || !(file instanceof TFile)) {
                console.warn(`File not found for frontmatter update: ${filePath}`);
                return false;
            }

            // Update frontmatter using Obsidian's API
            await app.fileManager.processFrontMatter(file, (frontmatter) => {
                frontmatter.image = imagePath;
            });

            return true;
        } catch (error: any) {
            console.error("Failed to update frontmatter:", error);
            return false;
        }
    }

    /**
     * Main function to generate and save monster image
     */
    static async generateMonsterImage(
        monster: Partial<Monster>,
        vault: Vault,
        options: ImageGenerationOptions
    ): Promise<string> {
        const loadingNotice = new Notice("Generating AI image...", 0);

        try {
            // Generate prompt
            const prompt = this.generatePromptFromMonster(monster, options.style);
            console.log("Generated DALL-E prompt:", prompt);

            // Generate image
            loadingNotice.setMessage("Requesting image from OpenAI...");
            const imageUrl = await this.generateImage(prompt, options.apiKey);

            // Save to vault
            loadingNotice.setMessage("Saving image to vault...");
            const vaultPath = await this.saveImageToVault(
                imageUrl,
                vault,
                options.saveFolder,
                monster.name || "creature"
            );

            loadingNotice.hide();
            new Notice(`AI image generated successfully! Saved to ${vaultPath}`);

            return vaultPath;
        } catch (error: any) {
            loadingNotice.hide();
            const errorMessage = error.message || "Unknown error occurred";
            new Notice(`Failed to generate image: ${errorMessage}`, 10000);
            throw error;
        }
    }
}
